	.equ @, $000
	.equ N,3
	.equ M,2
	.equ STACKTOP, $E00

	; use CBA method for arrays since only have to pass address of the array to be transposed

	lds#	STACKTOP
	ldf#	0

	psh#	matrix	; loading stack in order
	psh#	N
	psh#	M
	psh#	$080

	jsr	transpose

	ads#	4	;destroy stack 
	hlt

matrix:	.word 1 
	.word 2
	.word 3
	.word 4
	.word 5
	.word 6
	
; Subroutine Start
	.equ @, $020
	.equ AT, 2
	.equ	N_, 4
	.equ	M_, 3
	.equ A, 5
	
transpose:		;decode stack information 
	pshf
	tsf
	ldx#	0
	clr i
	lda i 
for_i:	
	cma !N_ 	
	jeq end_transp

	mul !M_ 
	sta pos	; matrix position 

	clr j
	
	
for_j:	lda j
	cma !M_ 
	jeq end_col
	
	mul !N_ 
	sta AT_pos	; equivalent A transpose position

	ldx j	; The transpose bit 
	adx pos
	lda& !A	
	
	ldx	i
	adx AT_pos
	sta& !AT

	inc j
	jmp for_j

end_col:	inc i
	lda i
	jmp for_i

end_transp:		; restoring fp and returning to calling function 
	popf
	rtn
			; essential variables for transpse
pos:	.word 0
AT_pos:	.word 0 
i:	.word 0
j:	.word 0
